---
title: 十大排序算法（四）— 归并排序
excerpt: 归并排序是一种基于分治思想的排序算法，它将一个大数组分成两个小数组，分别对它们进行排序，然后再将两个有序的小数组合并成一个有序的大数组。归并排序的时间复杂度是O(nlogn)，空间复杂度是O(n)。
categories:
 - [前端, javascript]
 - [算法, 排序算法]
tags: 
 - 前端
 - 算法
 - javascript
 - 排序算法
---

# 归并排序

归并排序是一种基于分治思想的排序算法，它将一个大数组分成两个小数组，分别对它们进行排序，然后再将两个有序的小数组合并成一个有序的大数组。归并排序的时间复杂度是O(nlogn)，空间复杂度是O(n)。

## 归并排序的原理

归并排序的原理可以用以下几个步骤来描述：

1. 如果数组长度为1，那么直接返回该数组，不需要排序。
2. 如果数组长度大于1，那么将数组从中间切分成两个子数组，左边为left，右边为right。
3. 对left和right分别递归地进行归并排序，得到两个有序的子数组。
4. 将两个有序的子数组合并成一个有序的大数组，这就是归并操作。
5. 返回合并后的大数组。

## 归并操作的实现

归并操作是将两个有序的子数组合并成一个有序的大数组的过程。我们可以用一个辅助函数来实现这个操作，该函数接收两个参数：left和right，分别表示要合并的两个子数组。该函数返回一个新的合并后的大数组。

我们可以用以下几个步骤来实现这个函数：

1. 创建一个空的结果数组res，用于存放合并后的元素。
2. 创建两个指针i和j，分别指向left和right的第一个元素。
3. 比较left[i]和right[j]，将较小者放入res，并移动相应的指针。
4. 重复步骤3，直到其中一个子数组被遍历完。
5. 将另一个子数组剩余的元素依次放入res。
6. 返回res。

## 归并排序的代码

根据上面的原理和实现，我们可以用javascript来编写归并排序的代码如下：
```js
// 归并操作
function merge(left, right) {
  // 创建结果数组
  let res = [];
  // 创建左右指针
  let i = 0;
  let j = 0;
  // 循环比较
  while (i < left.length && j < right.length) {
    // 将较小者放入结果
    if (left[i] < right[j]) {
      res.push(left[i]);
      i++;
    } else {
      res.push(right[j]);
      j++;
    }
  }
  // 处理剩余元素
  while (i < left.length) {
    res.push(left[i]);
    i++;
  }
  while (j < right.length) {
    res.push(right[j]);
    j++;
  }
  // 返回结果
  return res;
}

// 归并排序
function mergeSort(arr) {
  // 如果长度为1，则直接返回
  if (arr.length === 1) {
    return arr;
  }

  // 计算中间索引
  let mid = Math.floor(arr.length /2);
  // 切分左右子数组
  let left = arr.slice(0,mid);
  let right = arr.slice(mid);

  // 对左右子数组递归地进行归并排序
  left = mergeSort(left);
  right = mergeSort(right);

  // 合并左右子数组，并返回结果
  return merge(left,right);
}
```

## 归并排序的测试

我们可以用以下代码来测试上面编写的归并排序函数：

```js
// 测试数据
let arr = [9,8,7,6,5,4,3,2,1];
// 调用归并排序函数，并打印
mergeSort(arr)
// [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 总结

归并排序是一种分治法的排序算法，它将一个数组分成两个或更多的子数组，对每个子数组进行排序，然后再将它们合并成一个有序的数组。归并排序的时间复杂度是O (nlogn)，空间复杂度是O (n)。 

时间复杂度的分析：归并排序需要进行logn次拆分和合并操作，每次操作涉及到n个元素的比较和移动，因此总共需要O (nlogn)的时间。 

空间复杂度的分析：归并排序需要额外的空间来存储临时数组和递归栈，临时数组用于存放合并后的有序序列，递归栈用于记录拆分和合并的过程。临时数组的大小为n，递归栈的深度为logn，因此总共需要O (n)的空间。 
