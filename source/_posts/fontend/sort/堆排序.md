---
title: 十大排序算法（六）— 堆排序
excerpt: 堆排序（Heapsort）是一种基于堆这种数据结构的排序算法。堆是一种特殊的完全二叉树，它满足以下性质：1. 大顶堆：每个节点的值都大于或等于其左右孩子节点的值。2. 小顶堆：每个节点的值都小于或等于其左右孩子节点的值。
categories:
 - [前端, javascript]
 - [算法, 排序算法]
tags: 
 - 前端
 - 算法
 - javascript
 - 排序算法
---

# JS堆排序

## 什么是堆排序？

堆排序（Heapsort）是一种基于堆这种数据结构的排序算法。堆是一种特殊的完全二叉树，它满足以下性质：

- 大顶堆：每个节点的值都大于或等于其左右孩子节点的值。
- 小顶堆：每个节点的值都小于或等于其左右孩子节点的值。

堆排序的基本思想是：

1. 将待排序序列构造成一个大顶堆（或小顶堆）。
2. 此时，整个序列的最大值（或最小值）就是堆顶的根节点。
3. 将其与末尾元素进行交换，此时末尾就为最大值（或最小值）。
4. 然后将剩余n-1个元素重新构造成一个堆，重复上述步骤，直到整个序列有序。

## 如何实现JS堆排序？

要实现JS堆排序，我们需要先了解如何用数组表示一个完全二叉树。假设数组从下标0开始存储数据，则对于任意一个位置i：

- 它的父节点位置为：(i - 1) / 2
- 它的左孩子位置为：2 * i + 1
- 它的右孩子位置为：2 * i + 2

例如，下图中的数组就表示了一个大顶堆：

![heap](https://img-blog.csdnimg.cn/20181205161409957.png)

接下来，我们需要实现两个核心函数：

- heapify：调整某个节点及其子树为一个合法的大顶堆（或小顶堆），假设该节点的左右子树已经是合法的大顶堆（或小顶堆）。
- buildHeap：从无序数组构建一个合法的大顶堆（或小顶堆），可以从最后一个非叶子节点开始依次向前调用heapify函数。

最后，我们可以利用buildHeap和heapify函数来实现JS堆排序。具体代码如下：

```js
// 堆排序的函数
function heapSort(arr) {
  // 先建立大根堆（从最后一个非叶子节点向上调整）
  for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {
    adjustHeap(arr, i, arr.length);
  }
  // 每次把堆顶的数与最后一个数交换，并重新调整堆
  for (let i = arr.length - 1; i > 0; i--) {
    [arr[0], arr[i]] = [arr[i], arr[0]];
    adjustHeap(arr, 0, i);
  }
  return arr;
}

// 堆调整函数
function adjustHeap(arr, i, len) {
  let temp = arr[i];
  // 将当前节点与其左右子节点比较，找出最大的那个
  for (let j = 2 * i + 1; j < len; j = 2 * j + 1) {
    if (j + 1 < len && arr[j + 1] > arr[j]) {
      j++;
    }
    // 如果子节点比父节点大，就交换
    if (arr[j] > temp) {
      arr[i] = arr[j];
      i = j;
    } else {
      break;
    }
  }
  arr[i] = temp;
}



// 测试数据
const testArr = [5, 2, 9, 1, 5, 6];
// 调用插入排序函数
const sortedArr = heapSort(testArr);
// 打印结果
console.log(sortedArr);
```

整个代码实现了快速排序的算法流程：

* heapSort 函数是堆排序的主体函数，使用大根堆实现从小到大的排序
* adjustHeap 函数是堆调整函数，用来调整大根堆，以保证堆顶的数是整个堆中最大的数

## 总结

堆排序是一种选择排序的改进版，利用了堆这种数据结构的性质。

* 它的时间复杂度为O(nlogn)，空间复杂度为O(1)。
* 它的优点在于其不需要额外的数组，只需要在原数组上操作，因此空间复杂度比较低。
* 同时，它还比较快，比较适合大规模数据的排序。不过，它的缺点是实现较为复杂，需要对堆数据结构有较深的了解。
* 同时，在实际应用中，由于需要频繁的交换元素，因此在排序速度上可能比较慢。
* 因此，需要根据实际情况选择排序方式。