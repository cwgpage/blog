<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>推荐比较好用的vscode插件</title>
    <link href="/blog/2024/07/05/recommend/vscode%E6%8F%92%E4%BB%B6/"/>
    <url>/blog/2024/07/05/recommend/vscode%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h2><h4 id="Code-Spell-Checker"><a href="#Code-Spell-Checker" class="headerlink" title="Code Spell Checker"></a>Code Spell Checker</h4><blockquote><p>能够帮助我们检查单词拼写是否出现错误，检查的规则遵循 <code>camelCase</code> （驼峰拼写法）</p></blockquote><h4 id="Vue-Language-Features-Volar"><a href="#Vue-Language-Features-Volar" class="headerlink" title="Vue Language Features (Volar)"></a>Vue Language Features (Volar)</h4><blockquote><p> <code>vue3</code> 的语法提示、高亮、格式化代码插件</p></blockquote><h4 id="Tailwind-CSS-IntelliSense"><a href="#Tailwind-CSS-IntelliSense" class="headerlink" title="Tailwind CSS IntelliSense"></a>Tailwind CSS IntelliSense</h4><blockquote><p>可以在 <code>vscode</code> 中使用 <code>Tailwind CSS</code> ，并进行类的提示</p></blockquote><h4 id="DotENV"><a href="#DotENV" class="headerlink" title="DotENV"></a>DotENV</h4><blockquote><p><code>.env</code> 语法突出显示</p></blockquote><h2 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h2><h4 id="Material-Icon-Theme"><a href="#Material-Icon-Theme" class="headerlink" title="Material Icon Theme"></a>Material Icon Theme</h4><blockquote><p>个性化项目的文件夹图标</p></blockquote><h4 id="CodeSnaP"><a href="#CodeSnaP" class="headerlink" title="CodeSnaP"></a>CodeSnaP</h4><blockquote><p>可以生成精美的代码截图、放大也不不会模糊</p></blockquote><h2 id="实用"><a href="#实用" class="headerlink" title="实用"></a>实用</h2><h4 id="koroFileHeader"><a href="#koroFileHeader" class="headerlink" title="koroFileHeader"></a>koroFileHeader</h4><blockquote><p> 快速生成注释（文件头部注释、函数解析注释）的插件。 快捷键：生成文件头部注释：<code>ctrl+win+i</code>、生成函数注释：<code>ctrl+win+t</code></p></blockquote><h4 id="Error-Lens"><a href="#Error-Lens" class="headerlink" title="Error Lens"></a>Error Lens</h4><blockquote><p>可以直接显示代码的错误，高亮当前行，根据不同的等级显示不同的颜色</p></blockquote><h4 id="Git-History"><a href="#Git-History" class="headerlink" title="Git History"></a>Git History</h4><blockquote><p><code>Git</code>历史、搜索和更多（包括<code>Git</code>日志）</p></blockquote><h4 id="GitLens-Git-supercharged"><a href="#GitLens-Git-supercharged" class="headerlink" title="GitLens - Git supercharged"></a>GitLens - Git supercharged</h4><blockquote><p>在vscode中便捷的操作git仓库，可以显示每一行的提交记录</p></blockquote><h4 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a>Live Server</h4><blockquote><p>开启一个本地服务，静态页项目需要</p></blockquote><h4 id="npm-Intellisense"><a href="#npm-Intellisense" class="headerlink" title="npm Intellisense"></a>npm Intellisense</h4><blockquote><p>用于在导入语句中自动完成<code>npm</code>模块</p></blockquote><h4 id="Image-preview"><a href="#Image-preview" class="headerlink" title="Image preview"></a>Image preview</h4><blockquote><p>鼠标悬停可以预览图片、显示图片的大小和尺寸，可以在css、js、vue等文件预览</p></blockquote><h4 id="Better-Comments"><a href="#Better-Comments" class="headerlink" title="Better Comments"></a>Better Comments</h4><blockquote><p>写出更个性的注释，<code>// * (绿色)// ! (红色)// ? (蓝色)// TODO</code></p></blockquote><h4 id="Codelf"><a href="#Codelf" class="headerlink" title="Codelf"></a>Codelf</h4><blockquote><p>变量命名的插件</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>推荐</category>
      
      <category>插件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
      <tag>插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐比较好用的浏览器插件</title>
    <link href="/blog/2024/07/05/recommend/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <url>/blog/2024/07/05/recommend/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h4 id="Tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a>Tampermonkey</h4><blockquote><p>可以下载和写脚本的插件，懂的都懂</p></blockquote><h4 id="AdGuard"><a href="#AdGuard" class="headerlink" title="AdGuard"></a>AdGuard</h4><blockquote><p>广告拦截器</p></blockquote><h4 id="Adblock-Plus"><a href="#Adblock-Plus" class="headerlink" title="Adblock Plus"></a>Adblock Plus</h4><blockquote><p>广告拦截器</p></blockquote><h4 id="iTab"><a href="#iTab" class="headerlink" title="iTab"></a>iTab</h4><blockquote><p>非常好用的新标签页，iTab 组件式图标自定义您的浏览器的标签页，精美日历、炫酷天气、每日头条、海量壁纸、常用网址随心订制</p></blockquote><h4 id="WeTab"><a href="#WeTab" class="headerlink" title="WeTab"></a>WeTab</h4><blockquote><p>新标签页，用小组件自定义你的新标签页，支持暗黑模式</p></blockquote><h4 id="沙拉查词"><a href="#沙拉查词" class="headerlink" title="沙拉查词"></a>沙拉查词</h4><blockquote><p>聚合词典划词翻译，专业划词翻译扩展，为交叉阅读而生</p></blockquote><h3 id="即时工具"><a href="#即时工具" class="headerlink" title="即时工具"></a>即时工具</h3><blockquote><p>包含有精选工具、视频工具、音频工具、图片工具、文档处理、文章转换、数据图表、办公辅助、文本工具、数字工具、加密工具、单位转换</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>推荐</category>
      
      <category>插件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>插件</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十大排序算法（五）— 快速排序</title>
    <link href="/blog/2024/07/05/fontend/sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/blog/2024/07/05/fontend/sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是一种高效的排序算法，它的基本思想是通过一趟排序将待排序的数组分成两个子数组，其中一个子数组的所有元素都小于另一个子数组的所有元素，然后对这两个子数组递归地进行快速排序，直到所有元素都有序。</p><h2 id="快速排序的实现"><a href="#快速排序的实现" class="headerlink" title="快速排序的实现"></a>快速排序的实现</h2><p>要实现快速排序，我们需要一个函数来划分数组，即将一个数组按照一个基准值（pivot）分成两部分，左边的部分都小于等于基准值，右边的部分都大于基准值。我们可以选择任意一个元素作为基准值，这里我们选择第一个元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 划分函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">arr, left, right</span>) &#123;<br>  <span class="hljs-comment">// 选择第一个元素作为基准值</span><br>  <span class="hljs-keyword">let</span> pivot = arr[left];<br>  <span class="hljs-comment">// 定义两个指针，i指向左边第二个元素，j指向右边最后一个元素</span><br>  <span class="hljs-keyword">let</span> i = left + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> j = right;<br>  <span class="hljs-comment">// 当i和j没有相遇时，循环执行以下操作</span><br>  <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>    <span class="hljs-comment">// 如果i指向的元素小于等于基准值，则i右移一位</span><br>    <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;<br>      i++;<br>    &#125;<br>    <span class="hljs-comment">// 如果j指向的元素大于基准值，则j左移一位</span><br>    <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; arr[j] &gt; pivot) &#123;<br>      j--;<br>    &#125;<br>    <span class="hljs-comment">// 如果此时i还在j的左边，则交换i和j指向的元素</span><br>    <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>      <span class="hljs-title function_">swap</span>(arr, i, j);<br>      i++;<br>      j--;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 最后交换left和j指向的元素，使得基准值位于正确的位置</span><br>  <span class="hljs-title function_">swap</span>(arr, left, j);<br>  <span class="hljs-comment">// 返回基准值的索引</span><br>  <span class="hljs-keyword">return</span> j;<br>&#125;<br><br><span class="hljs-comment">// 辅助函数，用于交换数组中两个位置的元素</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">arr, i, j</span>) &#123;<br>  <span class="hljs-keyword">let</span> temp = arr[i];<br>  arr[i] = arr[j];<br>  arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了划分函数之后，我们就可以写出快速排序函数了。它接收三个参数：待排序的数组arr、起始索引left和结束索引right。如果left小于right，则说明还有至少两个元素需要排序。此时我们调用划分函数得到基准值所在位置pivotIndex，并对左右两个子数组递归地进行快速排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 快速排序函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr, left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-comment">// 如果起始索引小于结束索引，则说明还有至少两个元素需要排序</span><br>  <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>    <span class="hljs-comment">// 调用划分函数得到基准值所在位置pivotIndex</span><br>    <span class="hljs-keyword">let</span> pivotIndex = <span class="hljs-title function_">partition</span>(arr, left, right);<br>    <span class="hljs-comment">// 对左边子数组进行快速排序</span><br>    <span class="hljs-title function_">quickSort</span>(arr, left, pivotIndex - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 对右边子数组进行快速排序</span><br>    <span class="hljs-title function_">quickSort</span>(arr, pivotIndex + <span class="hljs-number">1</span>, right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>快速排序是一种不稳定（相同大小数据可能会改变顺序）但高效（平均时间复杂度为O(nlogn)，最坏情况为O(n^2)，空间复杂度为O(logn)）的算法。它是一种原地排序算法，不需要额外空间。它也是一种不稳定排序算法，即可能改变相同元素之间的相对顺序。它适合处理大规模且无序或近乎无序。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>javascript</category>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>算法</tag>
      
      <tag>javascript</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十大排序算法（三）— 插入排序</title>
    <link href="/blog/2024/07/05/fontend/sort/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/blog/2024/07/05/fontend/sort/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序的时间复杂度为O(n^2)，空间复杂度为O(1)，适合用于小规模或基本有序的数据集。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h2 id="JS-代码实现"><a href="#JS-代码实现" class="headerlink" title="JS 代码实现"></a>JS 代码实现</h2><p>以下是JS代码实现插入排序的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> len = arr.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">var</span> preIndex, current;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>    preIndex = i - <span class="hljs-number">1</span> ;<br>    current = arr [i];<br>    <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr [preIndex] &gt; current) &#123;<br>      arr [preIndex+ <span class="hljs-number">1</span>] = arr [preIndex];<br>      preIndex--;<br>    &#125;<br>    arr [preIndex+ <span class="hljs-number">1</span>] = current;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>插入排序的最好情况是当输入数组已经有序时，此时只需要进行n-1次比较和0次移动，时间复杂度为O(n)。最坏情况是当输入数组逆序时，此时需要进行n(n-1)&#x2F;2次比较和移动，时间复杂度为O(n^2)。平均情况下，时间复杂度也为O(n^2)。</p><p>插入排序是一种稳定的排序算法，即相同值的元素在输出数组中保持原来的顺序。这是因为在扫描已排序序列时，如果遇到相等或更小的值，则停止移动，并将新元素放在当前位置之后。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了JS实现插入排序的算法步骤、代码示例和分析。插入排序是一种简单易懂但效率不高的算法，在处理小规模或基本有序的数据集时可以考虑使用。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>javascript</category>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>算法</tag>
      
      <tag>javascript</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十大排序算法（二）— 选择排序</title>
    <link href="/blog/2024/07/05/fontend/sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/blog/2024/07/05/fontend/sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序（Selection-sort）是一种简单直观的排序算法，它的基本思想是：在未排序序列中找到最小（或最大）元素，将其放到已排序序列的末尾，然后重复这个过程，直到所有元素都排好序。</p><h2 id="选择排序的原理"><a href="#选择排序的原理" class="headerlink" title="选择排序的原理"></a>选择排序的原理</h2><p>选择排序的原理可以用以下步骤来描述：</p><ol><li>从未排序序列中找出最小（或最大）元素，与第一个元素交换位置。</li><li>从剩余未排序序列中找出最小（或最大）元素，与第二个元素交换位置。</li><li>以此类推，直到所有元素都排好序。</li></ol><h2 id="选择排序的示例"><a href="#选择排序的示例" class="headerlink" title="选择排序的示例"></a>选择排序的示例</h2><p>假设我们有一个数组 [5, 3, 6, 2, 10]，我们要对它进行升序排列。我们可以按照以下步骤进行选择排序：</p><ol><li>在 [5, 3, 6, 2, 10] 中找到最小元素为 2，与第一个元素交换位置，得到 [2, 3, 6, 5, 10]。</li><li>在 [3, 6, 5, 10] 中找到最小元素为 3，与第二个元素交换位置，得到 [2, 3, 6, 5 ,10]。</li><li>在 [6 ,5 ,10] 中找到最小元素为5 ，与第三个元素交换位置，得到 [2 ,3 ,5 ,6 ,10]。</li><li>在 [6 ,10] 中找到最小元素为6 ，与第四个元素交换位置，得到 [2 ,3 ,5 ,6 ,10]。</li><li>最后一个元素已经是最大的了，不需要再交换。</li></ol><h2 id="JS实现选择排序"><a href="#JS实现选择排序" class="headerlink" title="JS实现选择排序"></a>JS实现选择排序</h2><p>我们可以用 JavaScript 来实现选择排序算法。首先我们需要定义一个函数来寻找数组中的最小值，并返回其索引：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMinIndex</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-comment">// 假设第一个元素是最小值</span><br>  <span class="hljs-keyword">let</span> min = arr[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">let</span> minIndex =<span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 遍历数组</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i =<span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">// 如果发现更小的值</span><br>    <span class="hljs-keyword">if</span> (arr[i] &lt; min) &#123;<br>      <span class="hljs-comment">// 更新最小值和索引</span><br>      min = arr[i];<br>      minIndex = i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 返回索引</span><br>  <span class="hljs-keyword">return</span> minIndex;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们需要定义一个函数来执行选择排序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectionSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-comment">// 创建一个新数组用来存放已排序的部分</span><br>  <span class="hljs-keyword">let</span> sortedArr = [];<br>  <span class="hljs-comment">// 获取原数组的长度</span><br>  <span class="hljs-keyword">let</span> length = arr.<span class="hljs-property">length</span>;<br>  <span class="hljs-comment">// 循环length次</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>    <span class="hljs-comment">// 找出当前未排序部分中的最小值索引</span><br>    <span class="hljs-keyword">let</span> minIndex = <span class="hljs-title function_">findMinIndex</span>(arr);<br>    <span class="hljs-comment">// 将该值从原数组中删除，并添加到新数组末尾</span><br>    sortedArr.<span class="hljs-title function_">push</span>(arr.<span class="hljs-title function_">splice</span>(minIndex ,<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]);<br>  &#125;<br>  <span class="hljs-comment">// 返回新数组</span><br>  <span class="hljs-keyword">return</span> sortedArr;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr =[<span class="hljs-number">5</span> ,<span class="hljs-number">3</span> ,<span class="hljs-number">6</span> ,<span class="hljs-number">2</span> ,<span class="hljs-number">10</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">selectionSort</span>(arr)); <span class="hljs-comment">//[2 ,3 ,5 ,6 ,10]</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>选择排序是一种简单易懂的算法，但它也有一些缺点。它的时间复杂度为 O(n^2)，空间复杂度为 O(1)，所以对于较大或较复杂的数据集来说效率不高。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>javascript</category>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>算法</tag>
      
      <tag>javascript</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十大排序算法（一）— 冒泡排序</title>
    <link href="/blog/2024/07/05/fontend/sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/blog/2024/07/05/fontend/sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="冒泡排序的定义"><a href="#冒泡排序的定义" class="headerlink" title="冒泡排序的定义"></a>冒泡排序的定义</h2><p>冒泡排序是一种简单的排序方法。</p><ul><li>基本思路是通过两两比较相邻的元素并交换它们的位置，从而使整个序列按照顺序排列。</li><li>该算法一趟排序后，最大值总是会移到数组最后面，那么接下来就不用再考虑这个最大值。</li><li>一直重复这样的操作，最终就可以得到排序完成的数组。</li></ul><p>这种算法是稳定的，即相等元素的相对位置不会发生变化。</p><ul><li>而且在最坏情况下，时间复杂度为O(n^2)，在最好情况下，时间复杂度为O(n)。</li></ul><p>因此，冒泡排序适用于数据规模小的场景。</p><h2 id="冒泡排序的流程"><a href="#冒泡排序的流程" class="headerlink" title="冒泡排序的流程"></a>冒泡排序的流程</h2><p>冒泡排序的流程如下：</p><ol><li>从第一个元素开始，逐一比较相邻元素的大小。</li><li>如果前一个元素比后一个元素大，则交换位置。</li><li>在第一轮比较结束后，最大的元素被移动到了最后一个位置。</li><li>在下一轮比较中，不再考虑最后一个位置的元素，重复上述操作。</li><li>每轮比较结束后，需要排序的元素数量减一，直到没有需要排序的元素。</li><li>排序结束。</li><li>这个流程会一直循环，直到所有元素都有序排列为止。</li></ol><h2 id="冒泡排序的代码"><a href="#冒泡排序的代码" class="headerlink" title="冒泡排序的代码"></a>冒泡排序的代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义函数，用于实现冒泡排序算法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-comment">// 外层循环，控制需要比较的轮数</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-comment">// 内层循环，控制每轮需要比较的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> - i; j++) &#123;<br>      <span class="hljs-comment">// 如果前一个元素比后一个元素大，则交换它们的位置</span><br>      <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>        [arr[j], arr[j + <span class="hljs-number">1</span>]] = [arr[j + <span class="hljs-number">1</span>], arr[j]];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 返回排序后的数组</span><br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">bubbleSort</span>(arr));<br><span class="hljs-comment">// 输出：[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><p>说明：</p><ol><li>冒泡排序是一种暴力枚举算法，通过多次循环比较相邻的元素，把最大的元素逐渐冒泡到数组末端。</li><li>外层循环：控制排序的趟数，每一轮排序会把最大的元素放到最后，因此每次循环需要比较的元素个数也会逐渐减少。</li><li>内层循环：比较相邻元素，如果左边元素比右边元素大，则交换位置。</li><li>冒泡排序是一种时间复杂度较高的算法，一般不用于大数据量的排序，但它很容易理解，是一种初学者学习排序算法的好</li></ol><h2 id="冒泡排序的时间复杂度"><a href="#冒泡排序的时间复杂度" class="headerlink" title="冒泡排序的时间复杂度"></a>冒泡排序的时间复杂度</h2><p>在冒泡排序中，每次比较两个相邻的元素，并交换他们的位置，如果左边的元素比右边的元素大，则交换它们的位置。这样的比较和交换的过程可以用一个循环实现。</p><ul><li><p>在最好的情况下，数组已经是有序的，那么比较和交换的次数是最少的。</p><ul><li>在这种情况下，比较次数是n-1次，交换次数是0次，其中n是数组的长度。</li></ul></li><li><p>在最坏的情况下，数组是逆序的，那么比较和交换的次数是最多的。</p><ul><li>在这种情况下，比较次数是n-1次，交换次数是n(n-1)&#x2F;2次，其中n是数组的长度。</li></ul></li><li><p>在平均情况下，比较和交换的次数取决于数组的排列方式。</p><ul><li>一般来说，平均情况下比较次数是n-1次，交换次数是n(n-1)&#x2F;4次，其中n是数组的长度。</li></ul></li></ul><p>冒泡排序的时间复杂度分析：</p><ul><li>最好情况：当序列已经有序，每次比较和交换操作都不会进行，只需要进行n-1次比较，时间复杂度为O(n)。</li><li>最坏情况：当序列完全逆序，需要进行n-1轮比较和n-1次交换操作，时间复杂度为O(n^2)。</li><li>平均情况：需要进行的比较和交换操作的次数在所有情况中的平均值，时间复杂度也是O(n^2)。</li></ul><p>由此可见，冒泡排序的时间复杂度主要取决于数据的初始顺序，最坏情况下时间复杂度是O(n^2)，不适用于大规模数据的排序。</p><h2 id="冒泡排序的总结"><a href="#冒泡排序的总结" class="headerlink" title="冒泡排序的总结"></a>冒泡排序的总结</h2><ul><li>冒泡排序适用于数据规模较小的情况，因为它的时间复杂度为O(n^2)，对于大数据量的排序会变得很慢。</li><li>同时，它的实现简单，代码实现也容易理解，适用于学习排序算法的初学者。</li><li>但是，在实际的应用中，冒泡排序并不常用，因为它的效率较低。</li><li>此外，冒泡排序比较和交换的次数较多，占用更多的存储空间和时间，不适用于处理大数据量的情况。</li><li>因此，在实际应用中，冒泡排序通常被更高效的排序算法代替，如快速排序、归并排序等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>javascript</category>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>算法</tag>
      
      <tag>javascript</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十大排序算法（六）— 堆排序</title>
    <link href="/blog/2024/07/05/fontend/sort/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/blog/2024/07/05/fontend/sort/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="JS堆排序"><a href="#JS堆排序" class="headerlink" title="JS堆排序"></a>JS堆排序</h1><h2 id="什么是堆排序？"><a href="#什么是堆排序？" class="headerlink" title="什么是堆排序？"></a>什么是堆排序？</h2><p>堆排序（Heapsort）是一种基于堆这种数据结构的排序算法。堆是一种特殊的完全二叉树，它满足以下性质：</p><ul><li>大顶堆：每个节点的值都大于或等于其左右孩子节点的值。</li><li>小顶堆：每个节点的值都小于或等于其左右孩子节点的值。</li></ul><p>堆排序的基本思想是：</p><ol><li>将待排序序列构造成一个大顶堆（或小顶堆）。</li><li>此时，整个序列的最大值（或最小值）就是堆顶的根节点。</li><li>将其与末尾元素进行交换，此时末尾就为最大值（或最小值）。</li><li>然后将剩余n-1个元素重新构造成一个堆，重复上述步骤，直到整个序列有序。</li></ol><h2 id="如何实现JS堆排序？"><a href="#如何实现JS堆排序？" class="headerlink" title="如何实现JS堆排序？"></a>如何实现JS堆排序？</h2><p>要实现JS堆排序，我们需要先了解如何用数组表示一个完全二叉树。假设数组从下标0开始存储数据，则对于任意一个位置i：</p><ul><li>它的父节点位置为：(i - 1) &#x2F; 2</li><li>它的左孩子位置为：2 * i + 1</li><li>它的右孩子位置为：2 * i + 2</li></ul><p>例如，下图中的数组就表示了一个大顶堆：</p><p><img src="https://img-blog.csdnimg.cn/20181205161409957.png" alt="heap"></p><p>接下来，我们需要实现两个核心函数：</p><ul><li>heapify：调整某个节点及其子树为一个合法的大顶堆（或小顶堆），假设该节点的左右子树已经是合法的大顶堆（或小顶堆）。</li><li>buildHeap：从无序数组构建一个合法的大顶堆（或小顶堆），可以从最后一个非叶子节点开始依次向前调用heapify函数。</li></ul><p>最后，我们可以利用buildHeap和heapify函数来实现JS堆排序。具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 堆排序的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">heapSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-comment">// 先建立大根堆（从最后一个非叶子节点向上调整）</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-title function_">adjustHeap</span>(arr, i, arr.<span class="hljs-property">length</span>);<br>  &#125;<br>  <span class="hljs-comment">// 每次把堆顶的数与最后一个数交换，并重新调整堆</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>    [arr[<span class="hljs-number">0</span>], arr[i]] = [arr[i], arr[<span class="hljs-number">0</span>]];<br>    <span class="hljs-title function_">adjustHeap</span>(arr, <span class="hljs-number">0</span>, i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// 堆调整函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">adjustHeap</span>(<span class="hljs-params">arr, i, len</span>) &#123;<br>  <span class="hljs-keyword">let</span> temp = arr[i];<br>  <span class="hljs-comment">// 将当前节点与其左右子节点比较，找出最大的那个</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; j &lt; len; j = <span class="hljs-number">2</span> * j + <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; len &amp;&amp; arr[j + <span class="hljs-number">1</span>] &gt; arr[j]) &#123;<br>      j++;<br>    &#125;<br>    <span class="hljs-comment">// 如果子节点比父节点大，就交换</span><br>    <span class="hljs-keyword">if</span> (arr[j] &gt; temp) &#123;<br>      arr[i] = arr[j];<br>      i = j;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  arr[i] = temp;<br>&#125;<br><br><br><br><span class="hljs-comment">// 测试数据</span><br><span class="hljs-keyword">const</span> testArr = [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><span class="hljs-comment">// 调用插入排序函数</span><br><span class="hljs-keyword">const</span> sortedArr = <span class="hljs-title function_">heapSort</span>(testArr);<br><span class="hljs-comment">// 打印结果</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sortedArr);<br></code></pre></td></tr></table></figure><p>整个代码实现了快速排序的算法流程：</p><ul><li>heapSort 函数是堆排序的主体函数，使用大根堆实现从小到大的排序</li><li>adjustHeap 函数是堆调整函数，用来调整大根堆，以保证堆顶的数是整个堆中最大的数</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>堆排序是一种选择排序的改进版，利用了堆这种数据结构的性质。</p><ul><li>它的时间复杂度为O(nlogn)，空间复杂度为O(1)。</li><li>它的优点在于其不需要额外的数组，只需要在原数组上操作，因此空间复杂度比较低。</li><li>同时，它还比较快，比较适合大规模数据的排序。不过，它的缺点是实现较为复杂，需要对堆数据结构有较深的了解。</li><li>同时，在实际应用中，由于需要频繁的交换元素，因此在排序速度上可能比较慢。</li><li>因此，需要根据实际情况选择排序方式。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>javascript</category>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>算法</tag>
      
      <tag>javascript</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十大排序算法（四）— 归并排序</title>
    <link href="/blog/2024/07/05/fontend/sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/blog/2024/07/05/fontend/sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序是一种基于分治思想的排序算法，它将一个大数组分成两个小数组，分别对它们进行排序，然后再将两个有序的小数组合并成一个有序的大数组。归并排序的时间复杂度是O(nlogn)，空间复杂度是O(n)。</p><h2 id="归并排序的原理"><a href="#归并排序的原理" class="headerlink" title="归并排序的原理"></a>归并排序的原理</h2><p>归并排序的原理可以用以下几个步骤来描述：</p><ol><li>如果数组长度为1，那么直接返回该数组，不需要排序。</li><li>如果数组长度大于1，那么将数组从中间切分成两个子数组，左边为left，右边为right。</li><li>对left和right分别递归地进行归并排序，得到两个有序的子数组。</li><li>将两个有序的子数组合并成一个有序的大数组，这就是归并操作。</li><li>返回合并后的大数组。</li></ol><h2 id="归并操作的实现"><a href="#归并操作的实现" class="headerlink" title="归并操作的实现"></a>归并操作的实现</h2><p>归并操作是将两个有序的子数组合并成一个有序的大数组的过程。我们可以用一个辅助函数来实现这个操作，该函数接收两个参数：left和right，分别表示要合并的两个子数组。该函数返回一个新的合并后的大数组。</p><p>我们可以用以下几个步骤来实现这个函数：</p><ol><li>创建一个空的结果数组res，用于存放合并后的元素。</li><li>创建两个指针i和j，分别指向left和right的第一个元素。</li><li>比较left[i]和right[j]，将较小者放入res，并移动相应的指针。</li><li>重复步骤3，直到其中一个子数组被遍历完。</li><li>将另一个子数组剩余的元素依次放入res。</li><li>返回res。</li></ol><h2 id="归并排序的代码"><a href="#归并排序的代码" class="headerlink" title="归并排序的代码"></a>归并排序的代码</h2><p>根据上面的原理和实现，我们可以用javascript来编写归并排序的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 归并操作</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-comment">// 创建结果数组</span><br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-comment">// 创建左右指针</span><br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 循环比较</span><br>  <span class="hljs-keyword">while</span> (i &lt; left.<span class="hljs-property">length</span> &amp;&amp; j &lt; right.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-comment">// 将较小者放入结果</span><br>    <span class="hljs-keyword">if</span> (left[i] &lt; right[j]) &#123;<br>      res.<span class="hljs-title function_">push</span>(left[i]);<br>      i++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.<span class="hljs-title function_">push</span>(right[j]);<br>      j++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 处理剩余元素</span><br>  <span class="hljs-keyword">while</span> (i &lt; left.<span class="hljs-property">length</span>) &#123;<br>    res.<span class="hljs-title function_">push</span>(left[i]);<br>    i++;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (j &lt; right.<span class="hljs-property">length</span>) &#123;<br>    res.<span class="hljs-title function_">push</span>(right[j]);<br>    j++;<br>  &#125;<br>  <span class="hljs-comment">// 返回结果</span><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 归并排序</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-comment">// 如果长度为1，则直接返回</span><br>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br><br>  <span class="hljs-comment">// 计算中间索引</span><br>  <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> /<span class="hljs-number">2</span>);<br>  <span class="hljs-comment">// 切分左右子数组</span><br>  <span class="hljs-keyword">let</span> left = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,mid);<br>  <span class="hljs-keyword">let</span> right = arr.<span class="hljs-title function_">slice</span>(mid);<br><br>  <span class="hljs-comment">// 对左右子数组递归地进行归并排序</span><br>  left = <span class="hljs-title function_">mergeSort</span>(left);<br>  right = <span class="hljs-title function_">mergeSort</span>(right);<br><br>  <span class="hljs-comment">// 合并左右子数组，并返回结果</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(left,right);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序的测试"><a href="#归并排序的测试" class="headerlink" title="归并排序的测试"></a>归并排序的测试</h2><p>我们可以用以下代码来测试上面编写的归并排序函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 测试数据</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br><span class="hljs-comment">// 调用归并排序函数，并打印</span><br><span class="hljs-title function_">mergeSort</span>(arr)<br><span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>归并排序是一种分治法的排序算法，它将一个数组分成两个或更多的子数组，对每个子数组进行排序，然后再将它们合并成一个有序的数组。归并排序的时间复杂度是O (nlogn)，空间复杂度是O (n)。 </p><p>时间复杂度的分析：归并排序需要进行logn次拆分和合并操作，每次操作涉及到n个元素的比较和移动，因此总共需要O (nlogn)的时间。 </p><p>空间复杂度的分析：归并排序需要额外的空间来存储临时数组和递归栈，临时数组用于存放合并后的有序序列，递归栈用于记录拆分和合并的过程。临时数组的大小为n，递归栈的深度为logn，因此总共需要O (n)的空间。 </p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>javascript</category>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>算法</tag>
      
      <tag>javascript</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>file和base64格式转换</title>
    <link href="/blog/2024/07/05/fontend/js/basics/file%E5%92%8Cbase64%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <url>/blog/2024/07/05/fontend/js/basics/file%E5%92%8Cbase64%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="base64转file"><a href="#base64转file" class="headerlink" title="base64转file"></a>base64转file</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * base64转file</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> base64 </span>&#125; <span class="hljs-variable">base64</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> string </span>&#125; filename 转换后的文件名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">&#123;</span>&#125;&#125; file</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">base64ToFile</span> = (<span class="hljs-params">base64, filename </span>)=&gt; &#123;<br>  <span class="hljs-keyword">let</span> arr = base64.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>  <span class="hljs-keyword">let</span> mime = arr[<span class="hljs-number">0</span>].<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/:(.*?);/</span>)[<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">let</span> suffix = mime.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">1</span>] ;<span class="hljs-comment">// 图片后缀</span><br>  <span class="hljs-keyword">let</span> bstr = <span class="hljs-title function_">atob</span>(arr[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">let</span> n = bstr.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> u8arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(n);<br>  <span class="hljs-keyword">while</span> (n--) &#123;<br>    u8arr[n] = bstr.<span class="hljs-title function_">charCodeAt</span>(n)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>([u8arr], <span class="hljs-string">`<span class="hljs-subst">$&#123;filename&#125;</span>.<span class="hljs-subst">$&#123;suffix&#125;</span>`</span>, &#123; <span class="hljs-attr">type</span>: mime &#125;)<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="file转base64"><a href="#file转base64" class="headerlink" title="file转base64"></a>file转base64</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * file转base64</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> * </span>&#125; file 图片文件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">base64</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">fileToBase64</span> = file =&gt; &#123;<br>  <span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br>  reader.<span class="hljs-title function_">readAsDataURL</span>(file);<br>  reader.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">return</span> e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span><br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="base64转blob-blob转file"><a href="#base64转blob-blob转file" class="headerlink" title="base64转blob, blob转file"></a>base64转blob, blob转file</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * base64转blob</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> base64 </span>&#125; <span class="hljs-variable">base64</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">blob</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">base64ToBlob</span> = base64 =&gt; &#123;<br>  <span class="hljs-keyword">let</span> arr = base64.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>),<br>    mime = arr[<span class="hljs-number">0</span>].<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/:(.*?);/</span>)[<span class="hljs-number">1</span>],<br>    bstr = <span class="hljs-title function_">atob</span>(arr[<span class="hljs-number">1</span>]),<br>    n = bstr.<span class="hljs-property">length</span>,<br>    u8arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(n);<br>  <span class="hljs-keyword">while</span> (n--) &#123;<br>    u8arr[n] = bstr.<span class="hljs-title function_">charCodeAt</span>(n);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([u8arr], &#123; <span class="hljs-attr">type</span>: mime &#125;);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * blob转file</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> blob </span>&#125; <span class="hljs-variable">blob</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> string </span>&#125; <span class="hljs-variable">fileName</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">blob</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">blobToFile</span> = (<span class="hljs-params">blob, fileName</span>) =&gt; &#123;<br>  blob.<span class="hljs-property">lastModifiedDate</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>  blob.<span class="hljs-property">name</span> = fileName;<br>  <span class="hljs-keyword">return</span> blob;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>javascript</tag>
      
      <tag>格式转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数组的高阶方法</title>
    <link href="/blog/2024/07/05/fontend/js/array/%E6%95%B0%E7%BB%84%E7%9A%84%E9%AB%98%E9%98%B6%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2024/07/05/fontend/js/array/%E6%95%B0%E7%BB%84%E7%9A%84%E9%AB%98%E9%98%B6%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a><code>forEach()</code></h1><div class="note note-primary">            <p>数组每个元素都执行一次回调函数(循环)。</p>          </div><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, index, arr)<br>&#125;)<br>参数：<br>- <span class="hljs-attr">item</span>: 数组中的每项元素<br>- <span class="hljs-attr">index</span>: 每项元素的做索引值<br>- <span class="hljs-attr">arr</span>: 数组本身<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>注意：<code>forEach</code>方法没有返回值，不能<code>return</code>，且该方法直接改变的是原数组。</p>          </div><p><strong>例子：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item + <span class="hljs-number">1</span>) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><h1 id="filter"><a href="#filter" class="headerlink" title="filter()"></a><code>filter()</code></h1><div class="note note-primary">            <p>检测数组元素，并返回符合条件所有元素的数组。</p>          </div><p><strong>语法:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, index, arr)<br>  <span class="hljs-keyword">return</span> 判断条件<br>&#125;)<br>参数：<br>- <span class="hljs-attr">item</span>: 数组中的每项元素<br>- <span class="hljs-attr">index</span>: 每项元素的做索引值<br>- <span class="hljs-attr">arr</span>: 数组本身<br></code></pre></td></tr></table></figure><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt; <span class="hljs-number">2</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr) <span class="hljs-comment">// [3, 4]</span><br></code></pre></td></tr></table></figure><h1 id="find"><a href="#find" class="headerlink" title="find()"></a><code>find()</code></h1><div class="note note-primary">            <p>检索数组，返回符合传入条件的第一个数组元素。</p>          </div><p><strong>语法:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, index, arr)<br>  <span class="hljs-keyword">return</span> 判断条件<br>&#125;)<br>参数：<br>- <span class="hljs-attr">item</span>: 数组中的每项元素<br>- <span class="hljs-attr">index</span>: 每项元素的做索引值<br>- <span class="hljs-attr">arr</span>: 数组本身<br></code></pre></td></tr></table></figure><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;<br>]<br><span class="hljs-keyword">let</span> d = arr.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;张三&#x27;</span>) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d) <span class="hljs-comment">// &#123;name: &#x27;张三&#x27;, age: 19&#125;</span><br></code></pre></td></tr></table></figure><h1 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a><code>findIndex()</code></h1><div class="note note-primary">            <p>检索数组，返回符合传入条件的第一个数组元素的索引。</p>          </div><p><strong>语法:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, index, arr)<br>  <span class="hljs-keyword">return</span> 判断条件<br>&#125;)<br>参数：<br>- <span class="hljs-attr">item</span>: 数组中的每项元素<br>- <span class="hljs-attr">index</span>: 每项元素的做索引值<br>- <span class="hljs-attr">arr</span>: 数组本身<br></code></pre></td></tr></table></figure><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">let</span> index = arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item === <span class="hljs-number">3</span>) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index)  <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a><code>reduce()</code></h1><div class="note note-primary">            <p>将数组所有的元素计算为一个值（从左到右）</p>          </div><p><strong>语法:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prod, item</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prod, item)<br>  <span class="hljs-keyword">return</span> prod + item<br>&#125;, value)<br>参数：<br>- <span class="hljs-attr">prod</span>: 之前计算的值<br>- <span class="hljs-attr">item</span>: 每项元素的做索引值<br>- <span class="hljs-attr">value</span>: 计算的初始值，默认为<span class="hljs-string">`0`</span><br></code></pre></td></tr></table></figure><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">let</span> newValue = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prod, item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> prod + item<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newValue) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><h1 id="some"><a href="#some" class="headerlink" title="some()"></a><code>some()</code></h1><div class="note note-primary">            <p>检测数组元素中是否有元素符合指定条件, 返回值<code>true/false</code></p>          </div><p><strong>语法:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, index, arr)<br>  <span class="hljs-keyword">return</span> 判断条件<br>&#125;)<br>参数：<br>- <span class="hljs-attr">item</span>: 数组中的每项元素<br>- <span class="hljs-attr">index</span>: 每项元素的做索引值<br>- <span class="hljs-attr">arr</span>: 数组本身<br></code></pre></td></tr></table></figure><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;王五&#x27;</span>]<br><span class="hljs-keyword">let</span> isZS = arr.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item === <span class="hljs-string">&#x27;张三&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isZS)  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h1 id="every"><a href="#every" class="headerlink" title="every()"></a><code>every()</code></h1><div class="note note-primary">            <p>检测数组元素的每个元素是否都符合条件.返回值<code>true/false</code></p>          </div><p><strong>语法:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, index, arr)<br>  <span class="hljs-keyword">return</span> 判断条件<br>&#125;)<br>参数：<br>- <span class="hljs-attr">item</span>: 数组中的每项元素<br>- <span class="hljs-attr">index</span>: 每项元素的做索引值<br>- <span class="hljs-attr">arr</span>: 数组本身<br></code></pre></td></tr></table></figure><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>]<br><span class="hljs-comment">// 判断数组中的每一项是否都大于5</span><br><span class="hljs-keyword">let</span> a = arr.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item &gt; <span class="hljs-number">5</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)  <span class="hljs-comment">// false</span><br><span class="hljs-comment">// 判断数组中的每一项是否都小于10</span><br><span class="hljs-keyword">let</span> a = arr.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item &lt; <span class="hljs-number">10</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h1 id="map"><a href="#map" class="headerlink" title="map()"></a><code>map()</code></h1><div class="note note-primary">            <p>处理数组的每个元素，并返回处理后的数组。</p>          </div><p><strong>语法:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, index, arr)<br>  <span class="hljs-keyword">return</span> 判断条件/对象<br>&#125;)<br>参数：<br>- <span class="hljs-attr">item</span>: 数组中的每项元素<br>- <span class="hljs-attr">index</span>: 每项元素的做索引值<br>- <span class="hljs-attr">arr</span>: 数组本身<br></code></pre></td></tr></table></figure><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;<br>]<br><span class="hljs-comment">// 用法一</span><br><span class="hljs-keyword">let</span> arr1 = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">name</span>) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1)  <span class="hljs-comment">// [&#x27;张三&#x27;, &#x27;李四&#x27;]</span><br><span class="hljs-comment">// 用法二</span><br><span class="hljs-keyword">let</span> arr2 = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    ...item,<br>    item.<span class="hljs-property">sex</span> = <span class="hljs-string">&#x27;男&#x27;</span><br>  &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2) <span class="hljs-comment">// [&#123;name: &#x27;张三&#x27;, age: 19, sex: &#x27;男&#x27;&#125;, &#123;name: &#x27;李四&#x27;, age: 20, sex: &#x27;男&#x27;&#125;]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>javascript</tag>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron 更新项目安装 electron-updater 自动更新安装</title>
    <link href="/blog/2024/07/05/fontend/electron/electron+electron-updater%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"/>
    <url>/blog/2024/07/05/fontend/electron/electron+electron-updater%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>需要准备一个静态服务，放置新版本的软件包；也可以使用插件等，我这边演示使用的是服务器</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm run electron-updater<br></code></pre></td></tr></table></figure><h2 id="编写更新代码"><a href="#编写更新代码" class="headerlink" title="编写更新代码"></a>编写更新代码</h2><h3 id="进程文件代码"><a href="#进程文件代码" class="headerlink" title="进程文件代码"></a>进程文件代码</h3><p>在项目的进程文件中创建update.ts文件，写入下面代码，注意：一定是放在程序的主进程文件中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/main/update.ts</span><br><br><span class="hljs-keyword">import</span> &#123; ipcMain &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; autoUpdater &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;electron-updater&quot;</span><br><br>autoUpdater.<span class="hljs-property">autoDownload</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否自动更新</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  * 在开启更新监听事件之前设置</span><br><span class="hljs-comment">  * 一定要保证该地址下面包含latest.yml文件和需要更新的exe文件</span><br><span class="hljs-comment">  */</span><br>autoUpdater.<span class="hljs-title function_">setFeedURL</span>(&#123;<br>  <span class="hljs-attr">provider</span>: <span class="hljs-string">&#x27;generic&#x27;</span>,<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http:******&#x27;</span>, <span class="hljs-comment">// 打包文件存放地址</span><br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (<span class="hljs-attr">win</span>: any) =&gt; &#123;<br>  <span class="hljs-comment">// 发送消息给渲染线程</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sendStatusToWindow</span>(<span class="hljs-params">status?: any, params?: any</span>) &#123;<br>    win.<span class="hljs-property">webContents</span>.<span class="hljs-title function_">send</span>(status, params);<br>  &#125;<br><br>  <span class="hljs-comment">// 正在检测</span><br>  autoUpdater.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;checking-for-update&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">sendStatusToWindow</span>(<span class="hljs-string">&#x27;Checking for update...&#x27;</span>);<br>  &#125;)<br><br>  <span class="hljs-comment">// 可以更新版本</span><br>  autoUpdater.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;update-available&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">info: any</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">sendStatusToWindow</span>(<span class="hljs-string">&#x27;log&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;可以更新版本&#x27;</span>, info &#125;)<br>    <span class="hljs-title function_">sendStatusToWindow</span>(<span class="hljs-string">&#x27;autoUpdater-canUpdate&#x27;</span>, info)<br>  &#125;)<br><br>  <span class="hljs-comment">// 更新错误</span><br>  autoUpdater.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err: any</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">sendStatusToWindow</span>(<span class="hljs-string">&#x27;log&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;更新错误&#x27;</span>, err &#125;)<br>    <span class="hljs-title function_">sendStatusToWindow</span>(<span class="hljs-string">&#x27;autoUpdater-error&#x27;</span>, err)<br>  &#125;)<br><br>  <span class="hljs-comment">// 发起更新程序</span><br>  ipcMain.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;autoUpdater-toDownload&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">sendStatusToWindow</span>(<span class="hljs-string">&#x27;log&#x27;</span>, <span class="hljs-string">&#x27;发起更新开始&#x27;</span>)<br>    autoUpdater.<span class="hljs-title function_">downloadUpdate</span>()<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-title function_">sendStatusToWindow</span>(<span class="hljs-string">&#x27;log&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;发起更新成功&#x27;</span>, r &#125;))<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">sendStatusToWindow</span>(<span class="hljs-string">&#x27;log&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;发起更新失败&#x27;</span>, err &#125;))<br>  &#125;)<br><br>  <span class="hljs-comment">// 正在下载的下载进度</span><br>  autoUpdater.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;download-progress&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">progressObj: any</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">sendStatusToWindow</span>(<span class="hljs-string">&#x27;log&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;正在下载的下载进度&#x27;</span>, progressObj &#125;)<br>    <span class="hljs-title function_">sendStatusToWindow</span>(<span class="hljs-string">&#x27;autoUpdater-progress&#x27;</span>, progressObj)<br>  &#125;)<br><br>  <span class="hljs-comment">// 下载完成</span><br>  autoUpdater.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;update-downloaded&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">sendStatusToWindow</span>(<span class="hljs-string">&#x27;log&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;下载完成&#x27;</span>, r &#125;)<br>    <span class="hljs-title function_">sendStatusToWindow</span>(<span class="hljs-string">&#x27;autoUpdater-downloaded&#x27;</span>)<br>  &#125;)<br><br>  <span class="hljs-comment">// 退出程序并安装</span><br>  ipcMain.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;exit-app&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    autoUpdater.<span class="hljs-title function_">quitAndInstall</span>()<br>  &#125;)<br><br>  <span class="hljs-comment">// 重新检查是否有新版本更新</span><br>  ipcMain.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;monitor-update-system&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    autoUpdater.<span class="hljs-title function_">checkForUpdates</span>()<br>  &#125;)<br><br>  <span class="hljs-comment">// 检测是否有更新</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    autoUpdater.<span class="hljs-title function_">checkForUpdates</span>();<br>  &#125;, <span class="hljs-number">5000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="渲染层文件代码"><a href="#渲染层文件代码" class="headerlink" title="渲染层文件代码"></a>渲染层文件代码</h3><p>在渲染层，renderer文件夹中创建组件（我这边是随便写的样式，可以自己修改）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;jspatch&quot;&gt;<br>    &lt;div v-if=&quot;showUpdater&quot; class=&quot;update-wrapper&quot;&gt;<br>      &lt;p&gt; &#123;&#123; `当前：【$&#123;downloadProcess.transferred&#125;】 / 共【$&#123;downloadProcess.total&#125;】` &#125;&#125;&lt;/p&gt;<br>      &lt;p&gt;进度：&#123;&#123; downloadProcess.percent &#125;&#125;&lt;/p&gt;<br>      &lt;p&gt;正在下载(&#123;&#123; downloadProcess.speed &#125;&#125;)......&lt;/p&gt;<br>    &lt;/div&gt;<br>    &lt;div v-if=&quot;isShow&quot;&gt;<br>      &lt;button @click=&quot;saveUpdate&quot;&gt;确认更新&lt;/button&gt;<br>      &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&#x27;ts&#x27;&gt;<br>import &#123; defineComponent, reactive, toRefs &#125; from &quot;vue&quot;;<br>import &#123; ipcRenderer &#125; from &quot;electron&quot;<br><br>export default defineComponent(&#123;<br>  name: &quot;Jspatch&quot;,<br>  setup() &#123;<br>    const data = reactive(&#123;<br>      showUpdater: false,<br>      downloadProcess: &#123;<br>        percent: 10,<br>        speed: 0,<br>        transferred: &#x27;1kb&#x27;,<br>        total: &quot;2M&quot;<br>      &#125;,<br>      isShow: false,<br>      text: &#x27;&#x27;<br>    &#125;);<br><br>    function saveUpdate() &#123;<br>      ipcRenderer.send(&quot;autoUpdater-toDownload&quot;);<br>    &#125;<br><br>    // 发现新版本 once<br>    ipcRenderer.on(&quot;autoUpdater-canUpdate&quot;, () =&gt; &#123;<br>      /*<br>       * 这儿会监听，如果info.version比现在版本小；就会触发；反之，不会触发<br>       */<br>      data.text = &#x27;发现新版本&#x27;<br>      data.isShow = true<br>    &#125;);<br>    // 下载进度<br>    ipcRenderer.on(&quot;autoUpdater-progress&quot;, (event, process) =&gt; &#123;<br>      if (process.transferred &gt;= 1024 * 1024) &#123;<br>        process.transferred =<br>          (process.transferred / 1024 / 1024).toFixed(2) + &quot;M&quot;;<br>      &#125; else &#123;<br>        process.transferred = (process.transferred / 1024).toFixed(2) + &quot;K&quot;;<br>      &#125;<br>      if (process.total &gt;= 1024 * 1024) &#123;<br>        process.total = (process.total / 1024 / 1024).toFixed(2) + &quot;M&quot;;<br>      &#125; else &#123;<br>        process.total = (process.total / 1024).toFixed(2) + &quot;K&quot;;<br>      &#125;<br>      if (process.bytesPerSecond &gt;= 1024 * 1024) &#123;<br>        process.speed =<br>          (process.bytesPerSecond / 1024 / 1024).toFixed(2) + &quot;M/s&quot;;<br>      &#125; else if (process.bytesPerSecond &gt;= 1024) &#123;<br>        process.speed = (process.bytesPerSecond / 1024).toFixed(2) + &quot;K/s&quot;;<br>      &#125; else &#123;<br>        process.speed = process.bytesPerSecond + &quot;B/s&quot;;<br>      &#125;<br>      process.percent = process.percent.toFixed(2);<br>      data.downloadProcess = process;<br>      data.showUpdater = true;<br>    &#125;);<br>    // 下载更新失败<br>    ipcRenderer.once(&quot;autoUpdater-error&quot;, (err) =&gt; &#123;<br>      console.log(&#x27;⚽ =&gt; 更新失败&#x27;, err)<br>      data.text = &#x27;更新失败！&#x27;<br>      data.showUpdater = false;<br>    &#125;);<br>    // 下载完成<br>    ipcRenderer.once(&quot;autoUpdater-downloaded&quot;, () =&gt; &#123;<br>      data.showUpdater = false;<br>      data.text = &#x27;更新完成，是否关闭应用程序安装新版本?&#x27;<br>      ipcRenderer.send(&quot;exit-app&quot;);<br>    &#125;);<br>    return &#123;<br>      ...toRefs(data),<br>      saveUpdate<br>    &#125;;<br>  &#125;,<br>&#125;);<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br><br>.update-wrapper &#123;<br>  width: 200px;<br>  height: 200px;<br>  font-weight: 700;<br>  color: red;<br>  background: #fff;<br>&#125;<br><br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>创建完成在app.vue中引用、使用</p><blockquote><p>注意：修改版本号一定是修改package.json中的版本号。</p></blockquote><h2 id="整体更新流程"><a href="#整体更新流程" class="headerlink" title="整体更新流程"></a>整体更新流程</h2><blockquote><p>检测到有新版本 —&gt; 手动触发下载 —&gt; 显示进度条 —&gt; 下载完成，手动选择安装</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>electron</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>electron</tag>
      
      <tag>electron-updater</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron 项目中主进程中需要知道的信息怎么在控制台中显示</title>
    <link href="/blog/2024/07/05/fontend/electron/electron%E6%89%93%E5%8D%B0/"/>
    <url>/blog/2024/07/05/fontend/electron/electron%E6%89%93%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="进程中的打印怎么在控制台中显示"><a href="#进程中的打印怎么在控制台中显示" class="headerlink" title="进程中的打印怎么在控制台中显示"></a>进程中的打印怎么在控制台中显示</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 进程中的文件，通过win进行发送</span><br>win.<span class="hljs-property">webContents</span>.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;log&#x27;</span>, <span class="hljs-string">&#x27;打印&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 渲染层中进行接收到log方法</span><br>ipcRenderer.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;log&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e, info</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info) <span class="hljs-comment">// 打印</span><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>electron</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>electron</tag>
      
      <tag>log</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jetbrains系列产品重置试用方法</title>
    <link href="/blog/2024/01/27/tutorials/Jetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%81%E9%87%8D%E7%BD%AE%E8%AF%95%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2024/01/27/tutorials/Jetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%81%E9%87%8D%E7%BD%AE%E8%AF%95%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="新试用机制"><a href="#新试用机制" class="headerlink" title="新试用机制"></a>新试用机制</h1><ul><li>使用网络上 <a href="https://3.jetbra.in/">热心大佬</a> 热心大佬收集总结的key，进入IDE后使用重置插件。</li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>webStorm</category>
      
      <category>激活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发工具</tag>
      
      <tag>webStorm</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios封装网络请求（方法二）</title>
    <link href="/blog/2022/12/06/fontend/js/axios/axios%E5%B0%81%E8%A3%85%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%88%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%89/"/>
    <url>/blog/2022/12/06/fontend/js/axios/axios%E5%B0%81%E8%A3%85%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%88%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="axios介绍"><a href="#axios介绍" class="headerlink" title="axios介绍"></a>axios介绍</h1><h2 id="什么是axios"><a href="#什么是axios" class="headerlink" title="什么是axios?"></a>什么是axios?</h2><blockquote><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><blockquote><ul><li>从浏览器中创建 XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF</li></ul></blockquote><h1 id="安装实用"><a href="#安装实用" class="headerlink" title="安装实用"></a>安装实用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install axios<br></code></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><blockquote><p>一般是会在单独的文件里封装axios的，一般取名为request.js（看个人习惯），request.js中的代码如下。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// request.js</span><br><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 创建一个axios的实例，用request接受</span><br><span class="hljs-keyword">const</span> request = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-comment">// baseUrl,这里填写请求的url</span><br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//127.0.0.1/, </span><br>  <span class="hljs-comment">// 超时时间</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">8000</span>,<br>  <span class="hljs-comment">// 请求头的设置，后续还可以更改</span><br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin-Type&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">false</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="请求拦截"><a href="#请求拦截" class="headerlink" title="请求拦截"></a>请求拦截</h3><blockquote><p>在请求拦截中一般放token等所有接口都需要的公共参数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// request.js</span><br><br>request.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;config&#x27;</span>, config)<br>    <span class="hljs-comment">// let token = localStorage.token || null</span><br>    <span class="hljs-comment">// config.headers.common[&#x27;Authorization&#x27;] = token</span><br>    <span class="hljs-keyword">return</span> config<br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><h3 id="响应拦截"><a href="#响应拦截" class="headerlink" title="响应拦截"></a>响应拦截</h3><blockquote><p>在相应拦截中我们可以处理数据等相关操作</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javasc">// request.js<br><br>request.interceptors.response.use(<br>  (response) =&gt; &#123;<br>    console.log(&#x27;response&#x27;, response)<br>    let &#123;status, message, data&#125; = response.data<br>    if (status !== 200) &#123;<br>      return Promise.reject(response.data || &#x27;发生错误&#x27;)<br>    &#125;<br>    return Promise.resolve(data)<br>  &#125;,<br>  (error) =&gt; &#123;<br>    return Promise.reject(error)<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="进一步封装post和get"><a href="#进一步封装post和get" class="headerlink" title="进一步封装post和get"></a>进一步封装post和get</h2><h3 id="封装get请求"><a href="#封装get请求" class="headerlink" title="封装get请求"></a>封装get请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// request.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url, params</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    request.<span class="hljs-title function_">get</span>(url, &#123; params &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>([<span class="hljs-literal">null</span>, res])<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>([err, <span class="hljs-literal">undefined</span>])<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="封装post请求"><a href="#封装post请求" class="headerlink" title="封装post请求"></a>封装post请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// request.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">url, data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    request.<span class="hljs-title function_">post</span>(url, data).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>([<span class="hljs-literal">null</span>, res])<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>([err, <span class="hljs-literal">undefined</span>])<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="使用封装好的post和get请求"><a href="#使用封装好的post和get请求" class="headerlink" title="使用封装好的post和get请求"></a>使用封装好的post和get请求</h1><blockquote><p>在api.js文件中引入并用封装好的post和get对api统一处理</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// api.js</span><br><br><span class="hljs-keyword">import</span> &#123;post, get&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/request&#x27;</span><br><br><span class="hljs-comment">// 登录</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;api/login&#x27;</span>, data)<br>&#125;<br><br><span class="hljs-comment">// 获取用户信息</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;api/userinfo&#x27;</span>, data)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>再点击登录按钮的时候我们调用登录的接口方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toLogin</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> [err, res] = <span class="hljs-keyword">await</span> <span class="hljs-title function_">login</span>(loginForm)<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这里是后端响应非200的情况&#x27;</span>, err)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 这里处理成功的响应（是200的情况）</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>axios</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>封装</tag>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webStorm 编辑器中引路的路径“@/“ 无法识别 有波浪线</title>
    <link href="/blog/2022/12/06/tutorials/webstorm%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E2%80%9C@_%E2%80%9C%E5%BC%95%E5%85%A5%E8%B7%AF%E5%BE%84%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E6%9C%89%E6%B3%A2%E6%B5%AA%E7%BA%BF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/blog/2022/12/06/tutorials/webstorm%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E2%80%9C@_%E2%80%9C%E5%BC%95%E5%85%A5%E8%B7%AF%E5%BE%84%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E6%9C%89%E6%B3%A2%E6%B5%AA%E7%BA%BF%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="webstorm-编辑器中引路的路径“-“-无法识别-有波浪线"><a href="#webstorm-编辑器中引路的路径“-“-无法识别-有波浪线" class="headerlink" title="webstorm 编辑器中引路的路径“@&#x2F;“ 无法识别 有波浪线"></a>webstorm 编辑器中引路的路径“@&#x2F;“ 无法识别 有波浪线</h1><blockquote><p>在webstorm中引用路径有下划线的问题，提示语法有问题。</p></blockquote><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>在项目的根路径下，也就是跟package.json同级的目录下创建<strong>jsconfig.json</strong>这个文件，在文中写入</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;baseUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;@/*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;src/*&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;exclude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;node_modules&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;dist&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>通过这个方法我们就可以解决webstorm使用@引入的路径有警告，报黄的问题，同时也可以点击引入的文件跳过去了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>webStorm</category>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发工具</tag>
      
      <tag>webStorm</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Alist + RaiDrive 实现将网盘挂载到本地</title>
    <link href="/blog/2022/12/06/tutorials/%E4%BA%91%E7%9B%98%E6%8C%82%E8%BD%BDAlist%20+%20RaiDrive/"/>
    <url>/blog/2022/12/06/tutorials/%E4%BA%91%E7%9B%98%E6%8C%82%E8%BD%BDAlist%20+%20RaiDrive/</url>
    
    <content type="html"><![CDATA[<h1 id="云盘挂载"><a href="#云盘挂载" class="headerlink" title="云盘挂载"></a>云盘挂载</h1><p>本教程是实用Alist + RaiDrive 实现网盘挂载，Alist可以添加很多种类的网盘，如阿里云盘、百度云盘、天翼云盘、谷歌云盘、123云盘、115云盘、一刻相机…</p><h2 id="安装AList"><a href="#安装AList" class="headerlink" title="安装AList"></a>安装AList</h2><p>[AList ](<a href="https://alist.nn.ci/zh/">Home | AList文档 (nn.ci)</a>)的安装方式有很多，这里我以 Windows 的手动安装为例</p><ol><li>打开<a href="https://www.jackxjz.com/?golink=aHR0cHM6Ly9naXRodWIuY29tL2FsaXN0LW9yZy9hbGlzdC9yZWxlYXNlcw==">这个链接</a>，找到自己相应的系统版本并下载</li></ol><p><img src="https://img-blog.csdnimg.cn/fb697b58e53549248dc38a3d47ef9dcb.png" alt="在这里插入图片描述"><br>2. 解压文件，并将 <code>alist.exe</code> 文件置于一个单独的文件夹<br>3. 点击上方地址栏，输入<code>cmd</code>回车或者在当前文件夹中打开<code>PowerShell</code><br>4. 输入<code>alist server</code>回车，若看到<code>start server @ 0.0.0.0:端口号</code>则代表启动成功<br><img src="https://img-blog.csdnimg.cn/93064975b5f148a0959ba348a0c41b83.png" alt="在这里插入图片描述"></p><ol start="5"><li><p>接下来我们用浏览器打开下方三种链接的其中一个</p><ul><li><a href="localhost:5244">localhost:5244</a></li><li><a href="127.0.0.1:5244">127.0.0.1:5244</a></li><li><a href="0.0.0.0:5244">0.0.0.0:5244</a></li></ul><blockquote><p>端口号以实际运行结果为主</p></blockquote></li></ol><p>  <img src="https://img-blog.csdnimg.cn/813752ddb52f430e8e91ab612d5ac868.png" alt="在这里插入图片描述"></p><ol start="6"><li>点击下方登录，默认用户名为<strong>admin</strong>，默认密码在终端界面，登录后页面右上角会有提示</li></ol><p><img src="https://img-blog.csdnimg.cn/e6429c7d3c8f4306b6b8b53a7823dbcd.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2f74fecef737449990b5ba24d3dd4454.png" alt="在这里插入图片描述"></p><h2 id="AList后台配置"><a href="#AList后台配置" class="headerlink" title="AList后台配置"></a>AList后台配置</h2><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><ol><li>点击下方管理，建议先修改用户名和密码</li></ol><p><img src="https://img-blog.csdnimg.cn/2b74b075152f400c895f6a62967180f5.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/1423d2a618424da6af6a443727779e4d.png" alt="在这里插入图片描述"></p><h3 id="添加存储"><a href="#添加存储" class="headerlink" title="添加存储"></a>添加存储</h3><ol><li>切换到存储选项卡，点击添加，不同网盘的配置方式不同，可看<a href="https://www.jackxjz.com/?golink=aHR0cHM6Ly9hbGlzdC5ubi5jaS96aC9ndWlkZS9kcml2ZXJzL2NvbW1vbi5odG1s">官方文档</a></li></ol><p><img src="https://img-blog.csdnimg.cn/b4e66798b0fe4e09879c464c17fdda50.png" alt="在这里插入图片描述"></p><h4 id="阿里云盘"><a href="#阿里云盘" class="headerlink" title="阿里云盘"></a>阿里云盘</h4><ol><li>打开 <a href="https://www.jackxjz.com/?golink=aHR0cHM6Ly9hbGlzdC5ubi5jaS96aC9ndWlkZS9kcml2ZXJzL2FsaXl1bmRyaXZlLmh0bWw=">AList 文档</a>，点击获取 Token</li><li>将 Token 填入刷新令牌中</li><li>根文件夹ID默认为<code>root</code>，若想添加单独的文件夹，只需用阿里云盘打开文件夹，网址最后的就是根文件夹ID</li></ol><h4 id="123云盘"><a href="#123云盘" class="headerlink" title="123云盘"></a>123云盘</h4><p>123云盘的配置就很简单了，只需要网盘的用户名和密码</p><p><img src="https://img-blog.csdnimg.cn/15f35589b2df44bbb7f0e9af77c73ab9.png" alt="在这里插入图片描述"></p><h2 id="安装-RaiDrive"><a href="#安装-RaiDrive" class="headerlink" title="安装 RaiDrive"></a>安装 RaiDrive</h2><p>在 Windows 电脑上，我们可以使用 <a href="%5BRaiDrive%5D(https://www.raidrive.com.cn/)">RaiDrive</a> 将 AList 挂载到本地</p><ol><li>打开 <a href="https://www.raidrive.com.cn/">RaiDrive</a> 官网，下载最新版 RaiDrive 并安装</li><li>安装完成后打开 RaiDrive，点击添加</li></ol><p><img src="https://img-blog.csdnimg.cn/4fdae5f4474a459ea0bcead527b86c23.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QgK7PJY4-1670040562036)(E:\mediaFile\RaiDrive.png)]"></p><ol start="3"><li>选择 NAS 里的 Webdav，选择一个盘符，取一个名字；取消勾选<strong>地址</strong>，填上地址（<code>127.0.0.1</code>）和端口号，路径填 <code>dav</code>，再填上用户名和密码，点击连接</li></ol><p><img src="https://img-blog.csdnimg.cn/778a99a415094797a5193276883e2efa.png" alt="在这里插入图片描述"></p><ol start="4"><li>就能在此电脑这里直接管理 AList 上的文件上的文件</li></ol><p><img src="https://img-blog.csdnimg.cn/d9984d7fea4b495b8e1439c034f3b246.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kAF4F6Nl-1670040562037)(E:\mediaFile\Alist.png)]"></p><blockquote><p>注意：因为<code>RaiDrive</code>无法识别容量所以才显示<code>7.99EB</code></p></blockquote><p>好了，这时候就挂在成功啦！</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>云盘挂载</category>
      
      <category>RaiDrive</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>Alist</tag>
      
      <tag>RaiDrive</tag>
      
      <tag>云盘挂载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步请求 同步写法async和await的用法</title>
    <link href="/blog/2022/12/06/fontend/js/es/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%20%E5%90%8C%E6%AD%A5%E5%86%99%E6%B3%95async%E5%92%8Cawait/"/>
    <url>/blog/2022/12/06/fontend/js/es/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%20%E5%90%8C%E6%AD%A5%E5%86%99%E6%B3%95async%E5%92%8Cawait/</url>
    
    <content type="html"><![CDATA[<h1 id="async-await-是什么"><a href="#async-await-是什么" class="headerlink" title="async&#x2F;await 是什么"></a>async&#x2F;await 是什么</h1><blockquote><p>async&#x2F;await 是ES7提出来主要解决Promise异步回调的问题。<br>async&#x2F;await可以让我们更优雅的实现异步编程的写法。</p></blockquote><h3 id="旧的写法"><a href="#旧的写法" class="headerlink" title="旧的写法"></a>旧的写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  getHomeData是我们用来请求数据的方法。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">getHomeData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 这个res,就是我们接口返回的数据</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;res,&#x27;</span> res)<br>    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>       <span class="hljs-comment">// res.data就是我们需要的数据</span><br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data,&#x27;</span> res.<span class="hljs-property">data</span>)<br>    &#125;<br>  &#125;)<br>&#125;,<br><span class="hljs-comment">// 再简单点 用解构赋值的方式可以更快的获取</span><br><span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-title function_">getHomeData</span>().<span class="hljs-title function_">then</span>(&#123;data, status&#125; =&gt; &#123;<br>   <span class="hljs-keyword">if</span> (status !== <span class="hljs-number">200</span>) <span class="hljs-keyword">return</span><br>     <span class="hljs-comment">// 解构出来的data,就是我们需要的数据</span><br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data,&#x27;</span> data)<br>   &#125;)<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="async-await-写法"><a href="#async-await-写法" class="headerlink" title="async&#x2F;await 写法"></a>async&#x2F;await 写法</h3><blockquote><p>我们可以在请求的函数前面加上asyne关键字，然后在请求的时候使用await关键字，这样我们在进行异步请求的时候就可以不要使用.then，直接使用res来进行接收，res就是接口返回的数据。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  getHomeData是我们用来请求数据的方法。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">async</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getHomeData</span>();<br>   <span class="hljs-comment">// 这个res,就是我们接口返回的数据</span><br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;res,&#x27;</span> res)<br>   <span class="hljs-keyword">if</span> (res.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>      <span class="hljs-comment">// res.data就是我们需要的数据</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data,&#x27;</span> res.<span class="hljs-property">data</span>)<br>   &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>简单写法</p><blockquote><p>我们还可以使用解构赋值的方式更简单的获取数据</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">let</span> &#123;data, status&#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getHomeData</span>();<br>   <span class="hljs-keyword">if</span> (status!==<span class="hljs-number">200</span>) <span class="hljs-keyword">return</span><br>   <span class="hljs-comment">// 这里的data就是我们要获取的数据</span><br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data,&#x27;</span> data)<br>&#125;,<br></code></pre></td></tr></table></figure><blockquote><p>这些就是async&#x2F;await的简单介绍了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>javascript</tag>
      
      <tag>async/await</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios封装网络请求（方法一）</title>
    <link href="/blog/2022/12/06/fontend/js/axios/axios%E5%B0%81%E8%A3%85%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%88%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%89/"/>
    <url>/blog/2022/12/06/fontend/js/axios/axios%E5%B0%81%E8%A3%85%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%88%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是axios"><a href="#什么是axios" class="headerlink" title="什么是axios?"></a>什么是axios?</h1><blockquote><p> Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p></blockquote><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><blockquote><ul><li>从浏览器中创建 XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF</li></ul></blockquote><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><blockquote><p>一般是会在单独的文件里封装axios的，一般取名为request.js（看个人习惯），index.js中的代码如下。<br> 说明：我这边是创建了axios的实例来封装的，并且可以扩展headers。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// request.js</span><br><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装网络请求</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; baseUrl 接口域名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; config 配置参数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; headers 请求头</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">request</span> = (<span class="hljs-params">baseUrl, config, headers</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> axios1 = axios.<span class="hljs-title function_">create</span>(&#123;<br>    <span class="hljs-attr">baseURL</span>: baseUrl, <br>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,<br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-comment">//&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,</span><br>      ...headers,<br>    &#125;,<br>  &#125;);<br>  <span class="hljs-comment">// 请求拦截</span><br>  axios1.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">//这里做的是请求前需要做的处理，一般携带token等之类的处理</span><br>      <span class="hljs-keyword">return</span> config;<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err &amp;&amp; err.<span class="hljs-property">request</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这里做请求错误处理&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err=&gt;链接服务器失败&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 返回一个错误</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>();<br>    &#125;<br>  );<br>  <span class="hljs-comment">// 响应拦截</span><br>  axios1.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 这里是处理响应成功的处理</span><br>    <span class="hljs-keyword">return</span> res<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err &amp;&amp; err.<span class="hljs-property">response</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这里做响应错误处理&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 返回一个错误</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>();<br>    &#125;<br>  );<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">axios1</span>(config);<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>到这里request.js文件我们已经封装好了。现在我们可以在别的文件来使用它，可以给予他封装post和get请求。</p></blockquote><blockquote><p>在其他文件中使用，我这里是在api.js中使用的（api.js主要是用来方网络请求的文件）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// api.js</span><br><br><span class="hljs-comment">// 我们先引入干刚刚封装好的request方法</span><br><span class="hljs-keyword">import</span> &#123; request &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/request&#x27;</span>;<br><br><span class="hljs-comment">// 这是接口域名</span><br><span class="hljs-keyword">let</span> baseUrls = <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装get方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; url 接口地址</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; params 传递的参数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; baseUrl 接口域名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; header 请求头</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">get</span> = (<span class="hljs-params">url, params = &#123;&#125;, baseUrl = baseUrls, header = &#123;&#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(baseUrl, &#123; url, params, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span> &#125;, header)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装get方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; url 接口地址</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; data 传递的参数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; baseUrl 接口域名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; header 请求头</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">post</span> = (<span class="hljs-params">url, data = &#123;&#125;, baseUrl = baseUrls, header = &#123;&#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(baseUrl, &#123; url, data, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span> &#125;, header)<br>&#125;<br><br><span class="hljs-comment">//使用 （可以把网络请求的方法放在一起）</span><br><span class="hljs-comment">// 举例 登录接口</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">login</span> = (<span class="hljs-params">data</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, data)<br>&#125;<br><span class="hljs-comment">// 这样我们就可以在别的地方来使用这个方法了</span><br></code></pre></td></tr></table></figure><blockquote><p>好了今天的axios封装就到这里了，希望对你有帮助。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>axios</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>封装</tag>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node版本管理工具nvm在windows系统使用方法</title>
    <link href="/blog/2022/12/05/backend/nodejs/node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7nvm%E5%9C%A8windows%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2022/12/05/backend/nodejs/node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7nvm%E5%9C%A8windows%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="node版本管理工具nvm在windows系统使用方法"><a href="#node版本管理工具nvm在windows系统使用方法" class="headerlink" title="node版本管理工具nvm在windows系统使用方法"></a>node版本管理工具nvm在windows系统使用方法</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h3><blockquote><p>尽管 NVM 并不支持 windows，但是可以运行在 WSL（Windows Subsystem for Linux）中，WSL 是一个可以运行在 Windows10上的一个 Linux子系统，WSL 安装包的地址：<a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p></blockquote><img src="https://cdn.nlark.com/yuque/0/2022/png/28469598/1669162809821-d3ffce95-3299-42f9-9b9b-0ec1f4cc83b3.png" referrerpolicy='no-referrer' /><h3 id="2-下载完毕以后解压缩，然后双击开始安装"><a href="#2-下载完毕以后解压缩，然后双击开始安装" class="headerlink" title="2. 下载完毕以后解压缩，然后双击开始安装"></a>2. 下载完毕以后解压缩，然后双击开始安装</h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fefeac5993084f6ca4a00664773e0f1d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" referrerpolicy='no-referrer' /><h3 id="3-选择-nvm-的安装路径"><a href="#3-选择-nvm-的安装路径" class="headerlink" title="3. 选择 nvm 的安装路径"></a>3. 选择 <code>nvm</code> 的安装路径</h3><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a5237fc320a4fa0be6b3ff67cbb21e0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" referrerpolicy='no-referrer' /><h3 id="4-选择-nodejs-的路径"><a href="#4-选择-nodejs-的路径" class="headerlink" title="4. 选择 nodejs 的路径"></a>4. 选择 <code>nodejs </code>的路径</h3><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79f651a8dcec4534b20e51180df334ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" referrerpolicy='no-referrer' /><h2 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a>检查是否安装成功</h2><p>在 <code>cmd</code> 中输入 <code>nvm -v</code> 查看版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvm -v<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装指定node版本(可省略小版本号)</span><br>nvm install v14.15.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到指定node版本(可省略小版本号)</span><br>nvm use v14.15.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到最新的node版本</span><br>nvm use node<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给不同的版本号设置别名</span><br>nvm alias node_cms 14.15.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用该别名</span><br>nvm use node_cms<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看已安装node列表</span><br>nvm ls 或 nvm list<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">用于卸载某个node版本</span><br>nvm uninstall (version)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">用于展示当前在windows系统运行的nvm版本</span><br>nvm version 或 nvm -v<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>后端</category>
      
      <category>nodejs</category>
      
      <category>nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>nodejs</tag>
      
      <tag>nvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
